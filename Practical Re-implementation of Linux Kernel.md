## 对论文要求

先能写出一篇工程论文，期望能够达到：

* 目标和意义都是明确的，不需要过多解释。
* 路线图步骤清晰，步步推进，符合逻辑。
* 为实现每个具体步骤，采取的具体措施和方法有必要性、可行性和合理性。
* 路线和步骤综合起来，能够实现预期目标。这方面有说服力。

暂不考虑HotOS这些学术论文要求的创新性，先达到上述基本目标，然后考虑是否能够提炼出符合HotOS要求的内容。



## 题目

中文题目：**渐进式重新实现Linux Kernel的可行方法**

英文题目：Practical Re-implementation of Linux Kernel

目前有很多新型操作系统内核的实现都可以归类为对Linux Kernel的重新实现。一方面，新内核希望能够保持对已有应用系统和驱动的支持，保持Linux生态延续性；另一方面，新内核希望通过全部或局部重构的方式，有效应对Linux Kernel中日益严重的内存/并发安全问题、扩展性问题和持续可维护性问题。即，既要继承资产，又要改造完善。实践上必须满足如下的要求。

<img src="./Practical Re-implementation of Linux Kernel.assets/image-20241224224450542.png" alt="image-20241224224450542" style="zoom:80%;" />

最基本的要求是：重新实现的新内核与Linux Kernel相比，必须功能上相等，性能上相当，面向资产的接口保持一致。并且在此基础上，还可能要求应用新的工具链、采取新的构建模式来重新实现内核，以获取在安全性、维护性等方面的额外收益。

实现符合这种要求的新内核是极具挑战的，需要为这种重新构建的过程找出可行的办法。

本文提出的方法的思路是：首先选择一个Linux Kernel的版本，对其进行组件化分解；然后用Rust实现的组件逐个替换C组件，可以对每次替换前后的内核进行功能和性能的对比，并修正和优化新实现；最后完成对Linux Kernel的重新实现。

<img src="./Practical Re-implementation of Linux Kernel.assets/image-20241225091715975.png" alt="image-20241225091715975" style="zoom:80%;" />

这个思路可以用忒修斯之舟来描述：对于一艘船，当我们采取逐块木板替换的方式时，最终将得到整体外观与功能上与原船完全一样的船，但是整个的翻新过程是由一系列微小的替换步骤构成的，每一块木板替换后，整船都可以出海航行以验证本次替换的影响。这个过程虽然没有起一个Theseus的名字，但可能更符合那个忒修斯之舟故事的想法。

重新实现的内核与Linux Kernel等价，具有以下的特性：

1. 继承了Linux的应用和驱动资产，兼容其生态。
2. 重新实现过程中和完成后，实现了组件化的新内核，带来了易扩展性和易维护性。
3. 最后用Rust实现的组件完全替换了原有C组件，在内存安全、并发安全方面获得了提升。



## 背景

目前有很多Novel OS Kernel尝试在某些领域或场景中替换Linux Kernel，以解决Linux Kernel在安全性、扩展性和可维护性方面的问题。它们在设计策略上有着不同的考虑：

<img src="./Practical Re-implementation of Linux Kernel.assets/image-20241224114330010.png" alt="image-20241224114330010" style="zoom:80%;" />

1. 是否能够不做修改的直接继承接管Linux资产？

   如果选择接管，就可以直接兼容Linux的成熟生态，降低用户适配和迁移的负担，但是相应的难度和工作量都会提升。

   如果选择不接管，就需要自建应用系统生态，支持用户应用向本系统迁移。当然也有部分领域本身对兼容Linux缺少必要性迫切性。

2. 除了接管应用系统，是否还接管驱动？

   Linux资产主要包括两类：

   * 第一类是各种基于Linux的应用系统、中间件、系统库等等，通常需要适配libc或者syscall。
   * 第二类是以module形式存在的已经模块化的驱动、文件系统以及其它功能扩展，需要适配module接口。

   <img src="./Practical Re-implementation of Linux Kernel.assets/image-20241224174946591.png" alt="image-20241224174946591" style="zoom:80%;" />

   第一类资产称为北向资产，接管它们是常规操作；第二类资产称为南向资产，目前很少有方案考虑对它们的直接接管。

   如果能够对第二类资产也能够不加修改的直接接管，将能够显著提升新开发的内核在各种硬件平台的移植能力。

3. 对于内核是全部组件化，还是延续Linux的做法仅实现部分组件化？

   Linux Kernel本身是部分组件化的，它由一个最核心的vmlinuz和一组可以在运行时动态加载的modules组成。但是这个最核心的vmlinuz集合了大部分的功能，内部充斥着各种相互依赖与调用，耦合性很高，导致修改任意一个局部，都有可能潜在的影响全局的任何部分。

   根本解决办法是把新内核中对应vmlinuz的核心部分也进行组件化分解，细分为更小粒度的组件，并且支持逐级构造的单调过程。这种办法称为全部组件化。

   另一种选择是继续延续Linux Kernel的设计，仅实现部分组件化。

4. 是从Linux Kernel渐进式的过渡到新内核？还是直接新内核？

   目前已知的内核实现方式都是直接实现，本文提出的方法是把Linux Kernel分解为组件，然后以渐进的方式把组件逐个替换为基于Rust实现的组件，逐步完成对Linux内核的重新实现。

   <img src="./Practical Re-implementation of Linux Kernel.assets/image-20241223225532848.png" alt="image-20241223225532848" style="zoom:80%;" />

   相对于已知方法的关键区别：本方法首先建立一个一次性的中间过渡过程；而其它重新实现Kernel的方法没有这个中间过渡。

总结一下，本文所述方法：

把原始的基于C语言实现的Linux Kernel，基于Rust语言进行重新实现。重新实现过程是渐进式的，首先对Linux Kernel进行了完全的组件化，然后把组件逐个替换为Rust组件，最终形成基于Rust的Linux Kernel的重新实现。Linux原始的应用系统、驱动等，都可以不加改动的被新实现直接接管。



## 目标和意义

提出一种渐进式的基于Rust语言重新实现Linux Kernel的方法。首先把Linux Kernel组件化，然后把C组件逐个替换为Rust组件，最后得到基于Rust的Linux内核的重新实现。

<img src="./Practical Re-implementation of Linux Kernel.assets/image-20241222225234900.png" alt="image-20241222225234900" style="zoom:80%;" />

该工作的意义：

1. 直接继承接管Linux的应用和驱动资产，兼容Linux生态。
2. 重新实现过程中和完成后，实现了完全组件化的新内核。内核的组件化解耦提升了扩展性和可维护性。
3. 基于Rust的重新实现提升了内存安全和并发安全。
4. 从原始Linux Kernel到等价的新内核的实现过程是基于组件粒度替换的渐进方式。可以对每次替换前后的内核版本进行功能、性能、可靠性等指标的对比和验证。渐进方式分解了重新实现过程的整体复杂性，提升了重新实现的准确性。



## 步骤

本方法包括两步：

1. 分解原始的Linux Kernel，实现完全组件化。

   在组件化基础上，把Linux Kernel的构建过程分解为一系列的连续的内核构建过程。从简单内核逐步过渡到复杂内核，最后得到一个组件化的、与原始Linux Kernel等价的内核实现。
1. 对于每个组件，逐个替换为Rust组件。

   每替换一个组件，对替换前后的内核版本进行功能、性能、可靠性等指标的对比和调整，保证整个替换过程是平缓渐进的过程。当Rust组件占比超过总量一半时，从以C语言为中心的优化转为以Rust语言为中心的优化。

### 步骤1 - 原始Linux Kernel的完全组件化

组件化后的Linux Kernel的框架 Booter + Other_Modules

Booter的功能：系统引导和组件加载与初始化

所有组件形成单向依赖，以支持单调的逐级构建



分解为组件(单向依赖关系) -> 形成有向无环图，自底向上的单调关系，因此自底向上的每一级都是一个DAG -> 任意结点作为根的DAG对应一个可以单独构建、运行、测试和验证的系统。

1. 复用当前的模块机制，从局部扩展到全局

   当前Linux Kernel支持部分的模块化，一个module包含一个到几个.c文件，再加上init函数构成。module通过EXPORT_SYMBOL导出公开函数或变量符号，其它module可以调用这些公开函数或变量。

   按照功能内聚的原则，复用现有模块机制，把所有的功能组件化。其中首个将被引导的组件称为booter，它除了负责最初的bootstrap过程，还负责加载、链接和初始化其它模块，它自身的引导过程加上各个模块的顺序初始化过程，即对应Linux Kernel的启动过程。

2. 组件的形式

   Linux kernel module (*.ko)实际是ELF格式

3. 作为ELF格式，组件的对外接口是低级的二进制符号形式，包括两类：

   对外公开的接口：Export Symbols，存放在专门的meta段中，可以被外部发现

   引用外部的接口：即Undef的符号，Booter在链接阶段为这些符号找到外部定义，填充它们的地址。

4. Booter组件

   Boot而起到引导作用，和链接作用。

   Booter包含两部分功能：引导部分来自于XXX，加载、链接模块的功能来自于load_module (kernel/module.c)。分析符号依赖时，建立了模块间的依赖顺序，基于该顺序，Booter最后会依次调用各个模块的初始化。

5. 组件的分解，打破相互依赖，形成有向无环图

   按照初始化和运行时调用关系，把依赖分为强依赖和弱依赖。对弱依赖基于回调机制进行反转。

   把组件可以通过接口公开的符号用EXPORT_SYMBOL导出到特殊段。

6. 组件之间的链接机制

   阶段：加载后，启动前。在目标代码层面，匹配U类型符号和(T|R|D|B)类型符号by NM，完成链接。

7. 逐级构建、测试与验证

展示形成的结果，基于Riscv64，可以运行静态Linux应用的完整DAG包含大约45个组件。

### 步骤2 - 用Rust组件逐个替换C组件，替换前后，功能相同，性能相当

1. 每个Rust组件是一个lib crate。
2. 禁止LTO优化，产生目标代码而非llvm中间码。这样可以与C在同一层面链接。
3. 同样用EXPORT导出符号
4. 导出和引用符号extern "C"。
5. 每个组件对等替换前后，测试功能和性能。
6. 候选组件选择机制。C与Rust的互备组件同时存在，可以通过配置切换。

### 步骤3 - 当骨干组件基本由Rust组件构成，且Rust组件占比达到50%以上是，以Rust为中心优化

把extern ABI接口统一替换为Rust的标准Trait接口或Rust函数接口。遗留的C组件反过来适应Rust组件的情况。

1. 分解原始Linux Kernel为组件化的过程是一次性的，替换完成之后与原始Linux成为并行的两条线。以后单独维护re-implementation，决定是否合并原始Linux升级后的特性。
2. Rust组件占据主流之后，ABI接口转为中间码接口。
3. 遗留C组件反向适配Rust的需要





## 需要说明的问题

1. 对Linux Kernel组件化的工作，是否需要随着Linux Kernel的版本升级而更新？

   从原始Linux Kernel到组件化的Linux Kernel的工作是一次性的。

   即把Linux Kernel分解为组件的工作，只是作为基于Rust重新实现Linux Kernel的前期准备阶段。一旦完成转换，就获得了一个与所选定Linux Kernel版本基线一致的Rust实现。将来独立在该Rust实现上进行工作，不需要再分解一次。

4. 与R4L的区别包括两点：

   * Linux原本的设计由两层构成：紧耦合的核心vmlinuz + 可动态加载的模块modules，二者之间原本就存在一个相对清晰的边界。R4L在这个边界上通过建立一个shim层，去支持Rust实现的模块。R4L仅仅是外部扩展，不触及内核的内核vmlinuz，也就无法解决内核的根本问题。而本方法主要是对内核的内核vmlinuz的组件分解和重构。
   * 从改造的思路上：R4L是保持核心不变，扩展出支持Rust开发的modules接口，把C的modules替换为Rust的modules；本方法正好相反，重点是核心部分的组件化分解和逐个组件替换，对于已有的外部modules先直接接管，在替换过程中属于次要地位。

5. 组件（或模块）粒度倾向于更小的粒度。从分解复杂性的角度，粒度较小的组件有利于最小化每次要解决的问题范围。其实Linux Kernel本身也是模块化或组件化的，它由一个最核心的vmlinuz和一组可以运行时动态加载的modules组成。但是这个最核心的vmlinuz集合了大部分的功能，内部充斥着各种相互依赖与调用，耦合性很高，导致修改任意一个局部，都有可能潜在的影响全局的任何部分。也就是说，根源在于vmlinuz模块过于庞大复杂了，解决办法是把它分解为一系列的组件，并且是把构造这个vmlinuz的过程进行分解，形成逐级构造的单调过程。

6. 组件分解的两种方式，横向-并列，纵向-嵌套。

   横向-并列：功能组件之间是并列的，没有相互直接关系。

   纵向-嵌套：较复杂功能的组件是嵌套较初级功能的组件形成的。

   构成内核的组件之间同时包含这两种关系。

   重要的是：任何一个功能组件，加上引导部分，再加上调用功能组件的逻辑部分，就可以形成一个组件化的内核系统。功能组件可以从简单到复杂逐级嵌套来建立，那么相应的，内核系统就可以随着组件的逐级升级而扩展。因此，任何一个复杂的组件化的内核系统的构建过程，可以分解为一系列的连续的从简单到复杂的内核系统的构建过程，即构建过程也是嵌套的；每个过程构成的内核都是可以运行、可测试可验证的，这样就把复杂问题转化成为一系列的简单问题。

   达到上述效果的根本保证是，组件间的单向依赖。单向依赖 -> 纵向嵌套 -> 过程嵌套。

7. XXX



## 验证工作



## 对Linux Kernel和Asterinas进行组件化分解的体会

### 1. 对于Linux Kernel

当我们自底向上，逐个引入组件时，发现十分困难。主要挑战是：

在引入一个组件过程中，发现它对内核其它很多部分都存在直接依赖；如果把依赖的部分作为组件识别出来之后，又会发现新识别出的组件依然面对这种问题；进而很快出现大量的相互依赖关系。

这反映出来的问题：Linux Kernel内部各个实现部分之间的相互耦合度是非常高的（这可能是句废话）。

由此导致的后果：在对Linux Kernel进行维护的整个生命周期中，当我们对任意一行代码进行修改时，该修改的影响可能扩散的范围很大，该影响路径有可能非常繁杂和隐晦，找出并控制这种影响的难度和成本有可能完全超出现实可接受的程度。这种复杂性是内核开发领域面临的最大挑战，Linux Kernel开源项目近年来就在经历这样的问题，并且可能已经接近极限。

复杂性不可能被消除，只能被转嫁和分解。组件化可能是分解复杂性，分而治之的基本手段。但是仅靠组件分解还不够，还需要基于组件实现对内核的逐级构建，且这种构建过程是单调的。我认为如此，才有可能把复杂性问题分解到逐级构建的一系列过程中，形成一系列简单问题，每次迭代都只需要在上次迭代的基础上， 去解决增量问题。

### 2. 对于Asterinas（蚂蚁的框内核，现在叫osdk+ostd）

论文宣称，该实现的基础是一个小型的TCB，并且根据研究者的经验，这个TCB的规模是可以被控制住，始终保持在一个非常低的规模下的。这个TCB目前就对应于ostd，它封装了所有unsafe的东西、所有对系统整体可能带来致命影响的部分，对上层暴露一个Sound的接口。所以，整个项目的运行部分可以认为是由两个组件构成，ostd和kernel，它们之间具有解耦的接口。

我认为组件的粒度太大，所以尝试了对这两个组件进行进一步的分解，发现难度很大，类似于分解Linux Kernel的体验。例如ostd，由于各个功能都是mod而非crate，并没有cargo.toml中dependicies的天然约束，导致相互（循环）依赖关系远大于ArceOS。因此将来我估计Asterinas将来上线后的维护过程中，会走上Linux Kernel的老路。

